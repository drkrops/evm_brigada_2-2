Лабораторная работа №4.  
Использование ассемблерных вставок в программах на C++. Команды пересылки
=====
Выполнили студенты группы ПМ-31:
* Ивашков Станислав
* Никулин Иван

(4 бригада)

## Задание Л4.з1.
### Текст задания:
Как в задании Л1.з4, создайте массивы 𝑀𝑠 из 16-битных целых чисел, 𝑀𝑙 из 32-битных целых чисел, 𝑀𝑞 из 64-битных целых чисел (длина и начальные значения аналогичны Л1.з4).  
Реализуйте для каждого массива 𝑀 вставку, записывающую непосредственное значение 16 в 𝑀[𝑖] для заданного 𝑖 ∈ [0, 𝑁) с использованием команды 𝑚𝑜𝑣, где выражение 𝑀[𝑖] является выходным параметром вставки в памяти. Так как оба операнда 𝑚𝑜𝑣 здесь не имеют определённого размера (непосредственное значение и память), необходимо указывать для 𝑚𝑜𝑣 суффикс размера: 𝑚𝑜𝑣𝑤, 𝑚𝑜𝑣𝑙, 𝑚𝑜𝑣𝑞.  
Здесь и далее все целочисленные массивы до и после изменения выводите в шестнадцатеричном представлении.

### Ключевые фрагменты программного кода:
```C++
// Вставка в массив Ms
asm (
    "mov $16, %%ax\n\t" // Непосредственное значение 16 в регистр
    "mov %%ax, %[dest]\n\t" // Вставка непосредственного значения в память
    : [dest] "+m" (Ms[index]) // Выходной параметр вставки в память
    :
    : "%ax" // Используемый регистр
);

// Вставка в массив Ml
asm (
    "mov $16, %%eax\n\t" // Непосредственное значение 16 в регистр
    "mov %%eax, %[dest]\n\t" // Вставка непосредственного значения в память
    : [dest] "+m" (Ml[index]) // Выходной параметр вставки в память
    :
    : "%eax" // Используемый регистр
);

// Вставка в массив Mq
asm (
    "mov $16, %%rax\n\t" // Непосредственное значение 16 в регистр
    "mov %%rax, %[dest]\n\t" // Вставка непосредственного значения в память
    : [dest] "+m" (Mq[index]) // Выходной параметр вставки в память
    :
    : "%rax" // Используемый регистр
);
```

### Вывод программы:
```bash
Ms (short): fade fade fade fade fade 
Ml (int): ade1a1da ade1a1da ade1a1da ade1a1da ade1a1da 
Mq (long long): c1a551f1ab1e c1a551f1ab1e c1a551f1ab1e c1a551f1ab1e c1a551f1ab1e 

После вставки:
Ms (short): fade fade 10 fade fade 
Ml (int): ade1a1da ade1a1da 10 ade1a1da ade1a1da 
Mq (long long): c1a551f1ab1e c1a551f1ab1e 10 c1a551f1ab1e c1a551f1ab1e 
```

### Комментарии к результатам:
1. **Массив Ms (short):**
   - Исходное значение массива Ms состояло из 16-битных чисел.
   - После вставки значения 16 по индексу 2, элемент массива Ms с индексом 2 изменился на 0x10 (16 в шестнадцатеричной системе).
   - Остальные элементы массива Ms остались неизменными.

2. **Массив Ml (int):**
   - Исходное значение массива Ml состояло из 32-битных чисел.
   - После вставки значения 16 по индексу 2, элемент массива Ml с индексом 2 изменился на 0x10 (16 в шестнадцатеричной системе).
   - Остальные элементы массива Ml остались неизменными.

3. **Массив Mq (long long):**
   - Исходное значение массива Mq состояло из 64-битных чисел.
   - После вставки значения 16 по индексу 2, элемент массива Mq с индексом 2 изменился на 0x10 (16 в шестнадцатеричной системе).
   - Остальные элементы массива Mq остались неизменными.

Реализация с использованием инлайн-ассемблера позволила вставить непосредственное значение 16 в указанные индексы массивов различных типов данных, сохраняя при этом их размерность.

## Задание Л4.з2.
### Текст задания:
Задание Л4.з2. Реализуйте для одного из массивов 𝑀 (по варианту согласно таблице Л4.1) вставку, записывающую непосредственное (−1) в 𝑀[𝑖], где адрес начала массива 𝑀 и индекс 𝑖 передаются как входные параметры в регистрах.Используйте компоненты эффективного адреса (𝐵𝑎𝑠𝑒, 𝐼𝑛𝑑𝑒𝑥, 2^S𝑐𝑎𝑙𝑒). Разрядность компонент 𝐵𝑎𝑠𝑒 и 𝐼𝑛𝑑𝑒𝑥 должна быть одинаковой, поэтому для переносимости вставки необходимо объявить переменную 𝑖 не как 𝑖𝑛𝑡 (4 байта как для 32-, так и для 64-битного режимов), а как 𝑠𝑖𝑧𝑒_𝑡 (размер равен размеру указателя).

### Номер и текст варианта:
Вариант - 1. Массив Ms.

### Ключевые фрагменты программного кода:
```C++
void insert_minus_one(short* Ms, size_t index) {
    asm (
        "mov %[index], %%rdi\n\t"    // Загрузка индекса в регистр rdi
        "mov %[base], %%rax\n\t"    // Загрузка базового адреса массива Ms в регистр rax
        "lea (%%rax,%%rdi,2), %%rdx\n\t"  // Вычисление адреса элемента по индексу
        "movw $-1, (%%rdx)"     // Запись значения -1 в элемент массива по вычисленному адресу
        :
        : [base] "r" (Ms), [index] "r" (index)
        : "%rax", "%rdx", "%rdi"
    );
}
```

### Вывод программы:
```bash
Before insertion:
Ms[0] = 0xfade
Ms[1] = 0xfade
Ms[2] = 0xfade
Ms[3] = 0xfade
Ms[4] = 0xfade

After insertion:
Ms[0] = 0xfade
Ms[1] = 0xfade
Ms[2] = 0xffff
Ms[3] = 0xfade
Ms[4] = 0xfade
```

### Комментарии к результатам:
**Массив Ms (short):**
- Исходное значение массива Ms состояло из 16-битных чисел.
- После вставки значения -1 по индексу 2, элемент массива Ms с индексом 2 изменился на 0xFFFF (при использовании 16-битных целых чисел -1 представляется как все биты, установленные в 1).
- Остальные элементы массива Ms остались неизменными.

Реализация использовала инструкцию ассемблера для загрузки адреса элемента массива по индексу и записи значения -1 в этот элемент. Это позволило вставить непосредственное значение (-1) в указанный индекс массива Ms, используя эффективный адрес и передавая адрес начала массива и индекс в качестве входных параметров.

## Задание Л4.з3.
### Текст задания:
Реализуйте вставку, записывающую непосредственное значение 0xBB в заданный байт 𝑀𝑞[𝑖] (по варианту согласно таблице Л4.2; младший байт считайте нулевым) с использованием одной команды 𝑚𝑜𝑣 (𝑚𝑜𝑣𝑏) и всех компонент эффективного адреса 𝐷𝑖𝑠𝑝(𝐵𝑎𝑠𝑒, 𝐼𝑛𝑑𝑒𝑥, 2^𝑆𝑐𝑎𝑙𝑒); адрес начала массива 𝑀𝑞 и индекс 𝑖 передаются как входные параметры в регистрах.

### Номер и текст варианта:
Вариант - 4. Шестой байт.

### Ключевые фрагменты программного кода:
```C++
void insert_value(long long* Mq, size_t index) {
    asm (
        "movq %[base], %%rax\n\t"          // Загрузка базового адреса массива Mq в регистр rax
        "leaq (%%rax, %[index], 8), %%rdx\n\t"  // Вычисление адреса элемента по индексу
        "addq $5, %%rdx\n\t"               // Прибавление 5 к адресу, чтобы получить шестой байт
        "movb $0xBB, (%%rdx)"              // Запись значения 0xBB в шестой байт элемента массива
        :
        : [base] "r" (Mq), [index] "r" (index)
        : "%rax", "%rdx"
    );
}
```

### Вывод программы:
```bash
Before insertion:
Mq[0] = c1a551f1ab1e
Mq[1] = c1a551f1ab1e
Mq[2] = c1a551f1ab1e
Mq[3] = c1a551f1ab1e
Mq[4] = c1a551f1ab1e

After insertion:
Mq[0] = c1a551f1ab1e
Mq[1] = c1a551f1ab1e
Mq[2] = bba551f1ab1e
Mq[3] = c1a551f1ab1e
Mq[4] = c1a551f1ab1e
```

### Комментарии к результатам:
**Массив Mq (long long):**
- Исходное значение массива Mq состояло из 64-битных чисел.
- После вставки значения 0xBB в шестой байт элемента массива Mq с индексом 2 (считая с нуля) значение этого байта изменилось на 0xBB.
- Остальные элементы массива Mq остались неизменными.

Реализация использовала инструкцию ассемблера для загрузки адреса элемента массива по индексу и записи значения 0xBB в указанный байт, используя все компоненты эффективного адреса (базовый адрес, индекс и масштаб).

## Задание Л4.з4.
### Текст задания:
Реализуйте вставку, записывающую в 𝑀[𝑖] значение 𝑥 (𝑀 по варианту согласно таблице Л4.1; размер переменной 𝑥 равен размеру элемента 𝑀), где значение 𝑥 передаётся как входной параметр в памяти, 𝑀 и 𝑖 — как входные параметры в регистрах. Так как команда x86 не может адресовать два операнда в памяти, прямая пересылка 𝑥 → 𝑀[𝑖] невозможна; используйте промежуточный регистр (таблица Л4.3).

### Номер и текст варианта:
Массив: Вариант - 1. Ms.  
Регистр: Вариант - 4. Регистр 𝑠𝑖 (𝑠𝑖𝑙/𝑠𝑖/𝑒𝑠𝑖/𝑟𝑠𝑖)

### Ключевые фрагменты программного кода:
```C++
void insert_value(short* Ms, size_t index, short x) {
    asm (
        "mov %[val], %%si\n\t"      // Загрузка значения x в промежуточный регистр si
        "leaq (%[base], %[index], 2), %%rdx\n\t"  // Вычисление адреса элемента по индексу
        "mov %%si, (%%rdx)"         // Запись значения x в элемент массива по вычисленному адресу
        :
        : [base] "r" (Ms), [index] "r" (index), [val] "r" (x)
        : "%si", "%rdx"
    );
}
```

### Вывод программы:
```bash
Before insertion:
Ms[0] = fade
Ms[1] = fade
Ms[2] = fade
Ms[3] = fade
Ms[4] = fade

After insertion:
Ms[0] = fade
Ms[1] = fade
Ms[2] = abcd
Ms[3] = fade
Ms[4] = fade
```

### Комментарии к результатам:

1. **Вставка значения в массив:**
- Функция `insert_value` реализует вставку значения `x` в массив `Ms` по указанному индексу `index`.
- Для этого используется ассемблерная вставка с помощью инструкций x86.
- Значение `x` загружается в промежуточный регистр `si`.
- Затем вычисляется адрес элемента массива `Ms` по индексу `index` с помощью инструкции `leaq`.
- Наконец, значение `x` записывается в элемент массива по вычисленному адресу.

2. **Использование промежуточных регистров:**
- Промежуточный регистр `si` используется для временного хранения значения `x`, прежде чем оно будет записано в массив.
- Регистр `rdx` используется для вычисления адреса элемента массива.

3. **Результаты:**
- Перед вставкой значение `x` равно `0xabcd`.
- После вставки это значение записывается в массив `Ms` по индексу 2.
- Остальные элементы массива остаются без изменений.

## Задание Л4.з5.
### Текст задания:
Реализуйте вставку, записывающую в 𝑀[𝑖] значение 𝑥 аналогично Л4.з4, но во вставку передаётся адрес &𝑥.

### Ключевые фрагменты программного кода:
```C++
void insert_value(short* Ms, size_t index, short x) {
    asm volatile (
        "mov %[val], %%si\n\t"      // Загрузка значения x в промежуточный регистр si
        "mov %%si, %[addr]"         // Запись значения x по адресу
        : [addr] "+m" (Ms[index])
        : [val] "r" (x)
        : "%si"
    );
}
```

### Вывод программы:
```bash
Before insertion:
Ms[0] = fade
Ms[1] = fade
Ms[2] = fade
Ms[3] = fade
Ms[4] = fade

After insertion:
Ms[0] = fade
Ms[1] = fade
Ms[2] = bb
Ms[3] = fade
Ms[4] = fade
```

### Комментарии к результатам:
**Массив Ms (short):**
- Исходное значение массива Ms состояло из 16-битных чисел.
- После вставки значения x (0xBB) по индексу 2, элемент массива Ms с индексом 2 изменился на 0xBB.
- Остальные элементы массива Ms остались неизменными.

Реализация вставки значения x была выполнена с использованием инструкции ассемблера, которая загружает значение x в регистр и затем записывает его по адресу, переданному в качестве входного параметра.

## Задание Л4.з6.
### Текст задания:
Задание Л4.з6. Реализуйте вставку, рассчитывающую для целочисленных 𝑥 и 𝑦 значения 𝑧 = 𝑥 + 𝑦 и 𝑤 = 𝑥 − 𝑦 при помощи команд 𝑎𝑑𝑑 и 𝑠𝑢𝑏. Разрядность указана в таблице Л4.4; переменные 𝑥, 𝑦, 𝑧, 𝑤 передаются во вставку как параметры (𝑧 и 𝑤 — выходные, 𝑥 и 𝑦 — входные).

### Номер и текст варианта:
Вариант - 2. 16 бит.

### Ключевые фрагменты программного кода:
```C++
#include <iostream>

void calculate_values(short x, short y, short& z, short& w) {
    z = x;  // Инициализируем переменную z значением x
    asm volatile (
        "add %[y], %[z]\n\t"  // Сложение x и y
        "sub %[y], %[w]\n\t"  // Вычитание y из x
        : [z] "+r" (z), [w] "+r" (w)
        : [y] "r" (y)
    );
}

int main() {
    short x = 4;
    short y = 5;
    short z = 0; // Инициализируем переменную z
    short w = x; // Инициализируем переменную w значением x

    calculate_values(x, y, z, w);

    std::cout << "x = " << x << ", y = " << y << std::endl;
    std::cout << "z = " << z << ", w = " << w << std::endl;

    return 0;
}

```

### Вывод программы:
```bash
x = 4, y = 5
z = 9, w = -1
```

### Комментарии к результатам:
1. **Переменные x, y, z, w:**
   - Переменные x и y были переданы в функцию calculate_values в качестве входных параметров.
   - Переменные z и w были переданы в функцию calculate_values как ссылки для получения результата.

2. **Вычисления:**
   - Переменная z была инициализирована значением x перед выполнением ассемблерных операций.
   - В ассемблерной вставке сначала производится сложение значения y с переменной z, результат которого записывается обратно в переменную z.
   - Затем из переменной w вычитается значение y, результат записывается обратно в переменную w.

3. **Результаты:**
   - После выполнения вычислений переменная z содержит сумму значений x и y (4 + 5 = 9).
   - Переменная w содержит разность значений x и y (4 - 5 = -1).

Эта реализация выполняет арифметические операции с использованием ассемблерной вставки, что позволяет эффективно работать с переменными типа short и получать результаты вычислений.

## Задание Л4.з7.
### Текст задания:
Определите, доступны ли на выбранной платформе расширения AVX и SSE, используя команду 𝑐𝑝𝑢𝑖𝑑 или документацию на процессор. Как в задании Л1.з4, создайте массивы 𝑀𝑓𝑙 из 64-битных чисел с плавающей запятой и 𝑀𝑓𝑠 из 32-битных чисел с плавающей запятой. Реализуйте вставку, записывающую в 𝑀[𝑖] значение 𝑥 с плавающей запятой аналогично Л4.з4 (𝑀 по варианту согласно таблице Л4.5; размер переменной 𝑥 равен размеру элемента 𝑀; 𝑥, 𝑀 и 𝑖 — параметры вставки), используя команды AVX 𝑣𝑚𝑜𝑣𝑠𝑑/𝑣𝑚𝑜𝑣𝑠𝑠 или их SSE-аналоги 𝑚𝑜𝑣𝑠𝑑/𝑚𝑜𝑣𝑠𝑠. Используйте промежуточный регистр 𝑥𝑚𝑚 i, где номер регистра 𝑖 ∈ [0, 5] рассчитывается как (№ − 1)%6 (по варианту).

### Номер и текст варианта:
Массив: Вариант - 2. Mfs  
Индекс: i = 3

### Ключевые фрагменты программного кода:
```C++
#include <iostream>

// Функция для проверки доступности расширений AVX и SSE
bool check_availability_avx_sse() {
#ifdef __AVX__
    std::cout << "AVX is available!" << std::endl;
    return true;
#elif defined(__SSE__)
    std::cout << "SSE is available!" << std::endl;
    return true;
#else
    std::cout << "Neither AVX nor SSE is available!" << std::endl;
    return false;
#endif
}

// Функция для вставки значения x в массив Mfs по индексу i
void insert_value(float* Mfs, size_t i, float x) {
    asm (
        "movss %[val], %%xmm3\n\t"      // Загрузка значения x в регистр xmm3
        "movss %%xmm3, %[addr]"       // Запись значения x по адресу
        : [addr] "+m" (Mfs[i])
        : [val] "m" (x)
        : "%xmm3"
    );
}

int main() {
    // Проверяем доступность AVX и SSE
    if (!check_availability_avx_sse()) {
        return 1;
    }

    // Создаем массивы Mfl и Mfs и заполняем их значением -8/5
    float Mfl[] = {-8.0f/5, -8.0f/5, -8.0f/5, -8.0f/5};
    float Mfs[] = {-8.0f/5, -8.0f/5, -8.0f/5, -8.0f/5};

    // Примерный индекс для вставки
    size_t index = 2;

    // Значение для вставки
    float x = 3.1415926;

    // Вставляем значение x в массив Mfs по индексу index
    insert_value(Mfs, index, x);
    // Вывод...
}
```

### Вывод программы:
```bash
SSE is available!
Mfs after insertion:
Mfs[0] = -1.6
Mfs[1] = -1.6
Mfs[2] = 3.14159
Mfs[3] = -1.6
```

### Комментарии к результатам:
1. **Проверка доступности AVX и SSE:**
   - Программа проверяет доступность расширений AVX и SSE в компиляторе.
   - Вывод программы сообщает о доступности SSE.

2. **Массив Mfs (32-битные числа с плавающей запятой):**
   - Исходное значение массива Mfs состоит из чисел -8.0f/5.
   - После вставки значения x (3.1415926) по индексу 2, элемент массива Mfs с индексом 2 содержит это значение.
   - Остальные элементы массива Mfs остаются неизменными.

3. **Ассемблерная вставка:**
   - Вставка значения x в массив Mfs осуществляется с использованием SSE-инструкций.
   - Значение x загружается в регистр xmm3, а затем записывается по адресу элемента массива Mfs с помощью инструкции movss.

## Задание Л4.з8.
### Текст задания:
Реализуйте вставку, записывающую в 𝑀[𝑖] значение с плавающей запятой, равное целочисленному значению 𝑥. Преобразование целочисленного 𝑥 к нужному виду выполните при помощи команд AVX 𝑣𝑐𝑣𝑡𝑠𝑖2𝑠𝑑/𝑣𝑐𝑣𝑡𝑠𝑖2𝑠𝑠 или их SSE-аналогов 𝑐𝑣𝑡𝑠𝑖2𝑠𝑑/𝑐𝑣𝑡𝑠𝑖2𝑠𝑠.

### Ключевые фрагменты программного кода:
```C++
// Функция для проверки доступности расширений AVX и SSE
bool check_availability_avx_sse() {
#ifdef __AVX__
    std::cout << "AVX is available!" << std::endl;
    return true;
#elif defined(__SSE__)
    std::cout << "SSE is available!" << std::endl;
    return true;
#else
    std::cout << "Neither AVX nor SSE is available!" << std::endl;
    return false;
#endif
}

// Функция для вставки значения x в массив Mfs по индексу i
void insert_value(float* Mfs, size_t i, int x) {
    asm (
        "cvtsi2ss %[val], %[xmm1]\n\t"   // Преобразование целочисленного x в число с плавающей запятой
        "movss %[xmm1], %[addr]"         // Запись значения в массив Mfs по адресу
        : [addr] "+m" (Mfs[i])
        : [val] "r" (x), [xmm1] "x" (0)
    );
}
```

### Вывод программы:
```bash
SSE is available!
Mfs after insertion:
Mfs[0] = -1.6
Mfs[1] = -1.6
Mfs[2] = 10
Mfs[3] = -1.6
Mfs[4] = -1.6
```

### Комментарии к результатам:
1. **Проверка доступности AVX и SSE:**
   - Программа проверяет доступность расширений AVX и SSE в компиляторе.
   - Вывод программы сообщает о доступности SSE.

2. **Массив Mfs (32-битные числа с плавающей запятой):**
   - Исходное значение массива Mfs состоит из чисел -8.0f/5.
   - После вставки целочисленного значения x (10) по индексу 2, элемент массива Mfs с индексом 2 содержит это значение.
   - Остальные элементы массива Mfs остаются неизменными.

3. **Ассемблерная вставка:**
   - Вставка значения x в массив Mfs осуществляется с использованием SSE-инструкций.
   - Производится преобразование целочисленного значения x в число с плавающей запятой при помощи инструкции `cvtsi2ss`.
   - Затем значение записывается по адресу элемента массива Mfs с помощью инструкции `movss`.
